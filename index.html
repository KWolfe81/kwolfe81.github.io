<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GPX Splitter</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { font-family: sans-serif; margin: 0; padding: 1rem; }
    #map { height: 400px; margin-top: 1rem; }
    input, button { margin: 0.5rem 0; display: block; }
  </style>
</head>
<body>
  <h1>GPX Splitter</h1>
  <input type="file" id="gpxFile" accept=".gpx" />
  <label for="segmentLength">Segment length (miles):</label>
  <input type="number" id="segmentLength" value="20" min="1" />
  <button onclick="splitGPX()">Split GPX</button>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet"></script>
  <script src="https://unpkg.com/@tmcw/togeojson"></script>
  <script src="https://unpkg.com/jszip/dist/jszip.min.js"></script>
  <script>
    let map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    function parseGPX(file, callback) {
      const reader = new FileReader();
      reader.onload = () => {
        const parser = new DOMParser();
        const xml = parser.parseFromString(reader.result, 'application/xml');
        const geojson = toGeoJSON.gpx(xml);
        callback(geojson);
      };
      reader.readAsText(file);
    }

    function haversine(a, b) {
      const R = 3958.8; // miles
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(b[1] - a[1]);
      const dLon = toRad(b[0] - a[0]);
      const lat1 = toRad(a[1]), lat2 = toRad(b[1]);
      const aVal = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(aVal));
    }

    function splitGeoJSONByDistance(geojson, segmentMiles) {
      const coords = geojson.features[0].geometry.coordinates;
      let output = [], segment = [coords[0]], dist = 0;

      for (let i = 1; i < coords.length; i++) {
        const d = haversine(coords[i-1], coords[i]);
        dist += d;
        segment.push(coords[i]);

        if (dist >= segmentMiles || i === coords.length - 1) {
          output.push({
            type: "Feature",
            geometry: { type: "LineString", coordinates: segment },
            properties: {}
          });
          segment = [coords[i]];
          dist = 0;
        }
      }
      return output;
    }

    function geojsonToGPX(features) {
      return `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="gpx-splitter">
  <trk><name>Split GPX</name><trkseg>
  ${features.geometry.coordinates.map(c => `<trkpt lat="${c[1]}" lon="${c[0]}" />`).join('\n  ')}
  </trkseg></trk>
</gpx>`;
    }

    function splitGPX() {
      const file = document.getElementById('gpxFile').files[0];
      const miles = parseFloat(document.getElementById('segmentLength').value);
      if (!file || !miles) return alert('Please provide a GPX file and segment length.');

      parseGPX(file, geojson => {
        const segments = splitGeoJSONByDistance(geojson, miles);
        const zip = new JSZip();
        map.eachLayer(l => { if (l instanceof L.Polyline) map.removeLayer(l); });

        segments.forEach((seg, idx) => {
          zip.file(`segment_${idx + 1}.gpx`, geojsonToGPX(seg));
          L.geoJSON(seg).addTo(map);
        });

        zip.generateAsync({ type: 'blob' }).then(content => {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(content);
          a.download = 'gpx_segments.zip';
          a.click();
        });

        const bounds = L.geoJSON({ type: 'FeatureCollection', features: segments }).getBounds();
        map.fitBounds(bounds);
      });
    }
  </script>
</body>
</html>
